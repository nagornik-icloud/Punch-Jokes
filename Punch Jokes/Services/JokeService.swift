import Foundation
import FirebaseFirestore
import FirebaseStorage
import SwiftUI

@MainActor
class JokeService: ObservableObject {
    // MARK: - Properties
    private let db = Firestore.firestore()
    private let storage = Storage.storage()
    
    @Published var jokes: [Joke] = []
    @Published var authorImages: [String: UIImage] = [:] // userId: UIImage
    @Published var isLoading = true
    @Published var error: Error?
    
    init() {
        print("üü£ JokeService: Initializing...")
        // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        if let savedJokes = LocalStorage.loadJokes() {
            jokes = savedJokes
            print("üü£ JokeService: Loaded \(savedJokes.count) jokes from local storage")
        }
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        for joke in jokes {
            if authorImages[joke.authorId] == nil,
               let savedImage = LocalStorage.loadImage(forUserId: joke.authorId) {
                authorImages[joke.authorId] = savedImage
                print("üü£ JokeService: Loaded image for user \(joke.authorId) from local storage")
            }
        }
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ —Å —Å–µ—Ä–≤–µ—Ä–∞
        Task {
            await loadInitialData()
        }
        print("üü£ JokeService: Initialization complete")
    }
    
    // MARK: - Data Loading
    func loadInitialData() async {
        print("üü£ JokeService: Starting initial data load")
        isLoading = true
        do {
            defer {
                isLoading = false
                print("üü£ JokeService: Initial data load completed")
            }
            
            // –ó–∞–≥—Ä—É–∂–∞–µ–º —à—É—Ç–∫–∏
            print("üü£ JokeService: Fetching jokes from Firestore...")
            let snapshot = try await db.collection("jokes").getDocuments()
            print("üü£ JokeService: Retrieved \(snapshot.documents.count) joke documents")
            
            var fetchedJokes: [Joke] = []
            
            for document in snapshot.documents {
                do {
                    var joke = try document.data(as: Joke.self)
                    
                    // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–∞–Ω—á–ª–∞–π–Ω—ã –¥–ª—è –∫–∞–∂–¥–æ–π —à—É—Ç–∫–∏
                    let punchlinesSnapshot = try await document.reference.collection("punchlines").getDocuments()
                    joke.punchlines = try punchlinesSnapshot.documents.compactMap { punchlineDoc in
                        try punchlineDoc.data(as: Punchline.self)
                    }
                    
                    fetchedJokes.append(joke)
                    print("üü£ JokeService: Successfully decoded joke: \(joke.id) with \(joke.punchlines.count) punchlines")
                } catch {
                    print("üü£ JokeService: Failed to decode joke from document \(document.documentID): \(error)")
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–∑–º–µ–Ω–∏–ª–∏—Å—å –ª–∏ –¥–∞–Ω–Ω—ã–µ
            let shouldUpdate = shouldUpdateLocalStorage(newJokes: fetchedJokes)
            if shouldUpdate {
                self.jokes = fetchedJokes
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —à—É—Ç–∫–∏ –ª–æ–∫–∞–ª—å–Ω–æ
                LocalStorage.saveJokes(fetchedJokes)
                print("üü£ JokeService: Data changed, updated jokes array with \(fetchedJokes.count) jokes")
            } else {
                print("üü£ JokeService: No changes detected in jokes data")
            }
            
            // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∞–≤—Ç–æ—Ä–æ–≤
            let uniqueAuthors = Set(jokes.map { $0.authorId })
            print("üü£ JokeService: Found \(uniqueAuthors.count) unique authors, loading their images")
            
            for authorId in uniqueAuthors {
                if authorImages[authorId] == nil {
                    print("üü£ JokeService: Loading image for author: \(authorId)")
                    if let image = try? await loadAuthorImage(for: authorId) {
                        authorImages[authorId] = image
                        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ
                        LocalStorage.saveImage(image, forUserId: authorId)
                        print("üü£ JokeService: Successfully loaded image for author: \(authorId)")
                    } else {
                        print("üü£ JokeService: Failed to load image for author: \(authorId)")
                    }
                }
            }
            
        } catch {
            print("üü£ JokeService: Error during initial data load: \(error)")
            self.error = error
        }
    }
    
    // MARK: - Joke Operations
    func addJoke(_ setup: String, authorId: String) async throws {
        let joke = Joke(
            id: UUID().uuidString,
            setup: setup,
            status: "active",
            authorId: authorId,
            createdAt: Date()
        )
        
        let jokeRef = db.collection("jokes").document(joke.id)
        try await jokeRef.setData(from: joke)
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        jokes.append(joke)
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ª–æ–∫–∞–ª—å–Ω–æ
        LocalStorage.saveJokes(jokes)
    }
    
    func incrementJokeViews(_ jokeId: String) async throws {
        print("üü£ JokeService: Incrementing views for joke \(jokeId)")
        let jokeRef = db.collection("jokes").document(jokeId)
        
        try await jokeRef.updateData([
            "views": FieldValue.increment(Int64(1))
        ])
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        if let index = jokes.firstIndex(where: { $0.id == jokeId }) {
            jokes[index].views += 1
            print("üü£ JokeService: Views updated for joke \(jokeId), new count: \(jokes[index].views)")
        }
    }
    
    func toggleJokeReaction(_ jokeId: String, isLike: Bool) async throws {
        print("üü£ JokeService: Toggling \(isLike ? "like" : "dislike") for joke \(jokeId)")
        let jokeRef = db.collection("jokes").document(jokeId)
        
        // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —à—É—Ç–∫–∏
        guard let index = jokes.firstIndex(where: { $0.id == jokeId }) else {
            print("üü£ JokeService: Joke not found in local state")
            return
        }
        
        let joke = jokes[index]
        let currentLikes = joke.likes
        let currentDislikes = joke.dislikes
        
        var updates: [String: Any] = [:]
        
        if isLike {
            if currentLikes == 1 {
                updates["likes"] = FieldValue.increment(Int64(-1))
            } else {
                updates["likes"] = FieldValue.increment(Int64(1))
                if currentDislikes == 1 {
                    updates["dislikes"] = FieldValue.increment(Int64(-1))
                }
            }
        } else {
            if currentDislikes == 1 {
                updates["dislikes"] = FieldValue.increment(Int64(-1))
            } else {
                updates["dislikes"] = FieldValue.increment(Int64(1))
                if currentLikes == 1 {
                    updates["likes"] = FieldValue.increment(Int64(-1))
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –≤ Firestore
        try await jokeRef.updateData(updates)
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        if isLike {
            if currentLikes == 1 {
                jokes[index].likes = 0
            } else {
                jokes[index].likes = 1
                if currentDislikes == 1 {
                    jokes[index].dislikes = 0
                }
            }
        } else {
            if currentDislikes == 1 {
                jokes[index].dislikes = 0
            } else {
                jokes[index].dislikes = 1
                if currentLikes == 1 {
                    jokes[index].likes = 0
                }
            }
        }
        
        print("üü£ JokeService: Reaction updated for joke \(jokeId), likes: \(jokes[index].likes), dislikes: \(jokes[index].dislikes)")
    }
    
    // MARK: - Punchline Operations
    func addPunchline(to jokeId: String, text: String, authorId: String) async throws {
        let punchline = Punchline(
            id: UUID().uuidString,
            text: text,
            likes: 0,
            dislikes: 0,
            status: "pending",
            authorId: authorId,
            createdAt: Date()
        )
        
        let punchlineRef = db.collection("jokes").document(jokeId).collection("punchlines").document(punchline.id)
        try await punchlineRef.setData(from: punchline)
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        if let index = jokes.firstIndex(where: { $0.id == jokeId }) {
            jokes[index].punchlines.append(punchline)
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ª–æ–∫–∞–ª—å–Ω–æ
            LocalStorage.saveJokes(jokes)
        }
    }
    
    func togglePunchlineReaction(_ jokeId: String, _ punchlineId: String, isLike: Bool) async throws {
        print("üü£ JokeService: Toggling \(isLike ? "like" : "dislike") for punchline \(punchlineId) in joke \(jokeId)")
        let punchlineRef = db.collection("jokes").document(jokeId).collection("punchlines").document(punchlineId)
        
        // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–∞–Ω—á–ª–∞–π–Ω–∞
        guard let jokeIndex = jokes.firstIndex(where: { $0.id == jokeId }),
              let punchlineIndex = jokes[jokeIndex].punchlines.firstIndex(where: { $0.id == punchlineId }) else {
            print("üü£ JokeService: Punchline not found in local state")
            return
        }
        
        let punchline = jokes[jokeIndex].punchlines[punchlineIndex]
        let currentLikes = punchline.likes
        let currentDislikes = punchline.dislikes
        
        var updates: [String: Any] = [:]
        
        if isLike {
            if currentLikes == 1 {
                updates["likes"] = FieldValue.increment(Int64(-1))
            } else {
                updates["likes"] = FieldValue.increment(Int64(1))
                if currentDislikes == 1 {
                    updates["dislikes"] = FieldValue.increment(Int64(-1))
                }
            }
        } else {
            if currentDislikes == 1 {
                updates["dislikes"] = FieldValue.increment(Int64(-1))
            } else {
                updates["dislikes"] = FieldValue.increment(Int64(1))
                if currentLikes == 1 {
                    updates["likes"] = FieldValue.increment(Int64(-1))
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –≤ Firestore
        try await punchlineRef.updateData(updates)
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        if isLike {
            if currentLikes == 1 {
                jokes[jokeIndex].punchlines[punchlineIndex].likes = 0
            } else {
                jokes[jokeIndex].punchlines[punchlineIndex].likes = 1
                if currentDislikes == 1 {
                    jokes[jokeIndex].punchlines[punchlineIndex].dislikes = 0
                }
            }
        } else {
            if currentDislikes == 1 {
                jokes[jokeIndex].punchlines[punchlineIndex].dislikes = 0
            } else {
                jokes[jokeIndex].punchlines[punchlineIndex].dislikes = 1
                if currentLikes == 1 {
                    jokes[jokeIndex].punchlines[punchlineIndex].likes = 0
                }
            }
        }
        
        print("üü£ JokeService: Reaction updated for punchline \(punchlineId), likes: \(jokes[jokeIndex].punchlines[punchlineIndex].likes), dislikes: \(jokes[jokeIndex].punchlines[punchlineIndex].dislikes)")
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ª–æ–∫–∞–ª—å–Ω–æ
        LocalStorage.saveJokes(jokes)
    }
    
    func updatePunchlineStatus(_ jokeId: String, _ punchlineId: String, status: String) async throws {
        let punchlineRef = db.collection("jokes").document(jokeId).collection("punchlines").document(punchlineId)
        
        try await punchlineRef.updateData([
            "status": status
        ])
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        if let jokeIndex = jokes.firstIndex(where: { $0.id == jokeId }),
           let punchlineIndex = jokes[jokeIndex].punchlines.firstIndex(where: { $0.id == punchlineId }) {
            jokes[jokeIndex].punchlines[punchlineIndex].status = status
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ª–æ–∫–∞–ª—å–Ω–æ
            LocalStorage.saveJokes(jokes)
        }
    }
    
    // MARK: - Helper Methods
    private func shouldUpdateLocalStorage(newJokes: [Joke]) -> Bool {
        // –ï—Å–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à—É—Ç–æ–∫ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å, –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å
        guard newJokes.count == jokes.count else {
            print("üü£ JokeService: Jokes count changed: local \(jokes.count) vs server \(newJokes.count)")
            return true
        }
        
        // –°–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–∞—Ä–∏ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
        let currentJokesDict = Dictionary(uniqueKeysWithValues: jokes.map { ($0.id, $0) })
        let newJokesDict = Dictionary(uniqueKeysWithValues: newJokes.map { ($0.id, $0) })
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ä–∞–∑–ª–∏—á–∏—è
        for (id, newJoke) in newJokesDict {
            guard let currentJoke = currentJokesDict[id] else {
                print("üü£ JokeService: Found new joke with id: \(id)")
                return true
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–ª—è —à—É—Ç–∫–∏
            if newJoke.setup != currentJoke.setup ||
               newJoke.status != currentJoke.status ||
               newJoke.views != currentJoke.views ||
               newJoke.likes != currentJoke.likes ||
               newJoke.dislikes != currentJoke.dislikes {
                print("üü£ JokeService: Joke \(id) has updated fields")
                return true
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞–Ω—á–ª–∞–π–Ω—ã
            if newJoke.punchlines.count != currentJoke.punchlines.count {
                print("üü£ JokeService: Punchlines count changed for joke \(id)")
                return true
            }
            
            // –°–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–∞—Ä–∏ –ø–∞–Ω—á–ª–∞–π–Ω–æ–≤ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
            let currentPunchlinesDict = Dictionary(uniqueKeysWithValues: currentJoke.punchlines.map { ($0.id, $0) })
            let newPunchlinesDict = Dictionary(uniqueKeysWithValues: newJoke.punchlines.map { ($0.id, $0) })
            
            for (punchlineId, newPunchline) in newPunchlinesDict {
                guard let currentPunchline = currentPunchlinesDict[punchlineId] else {
                    print("üü£ JokeService: Found new punchline \(punchlineId) for joke \(id)")
                    return true
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª—è –ø–∞–Ω—á–ª–∞–π–Ω–∞
                if newPunchline.text != currentPunchline.text ||
                   newPunchline.status != currentPunchline.status ||
                   newPunchline.likes != currentPunchline.likes ||
                   newPunchline.dislikes != currentPunchline.dislikes {
                    print("üü£ JokeService: Punchline \(punchlineId) has updated fields")
                    return true
                }
            }
        }
        
        return false
    }
    
    func getJokesByAuthor(_ authorId: String) -> [Joke] {
        return jokes.filter { $0.authorId == authorId }
    }
    
    func getPunchlines(for jokeId: String, withStatus status: String? = nil) -> [Punchline] {
        guard let joke = jokes.first(where: { $0.id == jokeId }) else { return [] }
        
        if let status = status {
            return joke.punchlines.filter { $0.status == status }
        }
        return joke.punchlines
    }
    
    func uploadAuthorImage(_ image: UIImage, userId: String) async throws {
        print("üü£ JokeService: Uploading image for author: \(userId)")
        
        guard let imageData = image.jpegData(compressionQuality: 0.7) else {
            throw NSError(domain: "", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to convert image to data"])
        }
        
        let storageRef = storage.reference().child("user_images/\(userId).jpg")
        _ = try await storageRef.putDataAsync(imageData)
        print("üü£ JokeService: Successfully uploaded image for author: \(userId)")
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à
        authorImages[userId] = image
        LocalStorage.saveImage(image, forUserId: userId)
    }
    
    private func loadAuthorImage(for userId: String) async throws -> UIImage? {
        let storageRef = storage.reference().child("user_images/\(userId).jpg")
        let data = try await storageRef.data(maxSize: 4 * 1024 * 1024)
        return UIImage(data: data)
    }
    
    func reloadAuthorImage(for userId: String) async {
        print("üü£ JokeService: Reloading image for author: \(userId)")
        if let image = try? await loadAuthorImage(for: userId) {
            authorImages[userId] = image
            LocalStorage.saveImage(image, forUserId: userId)
            print("üü£ JokeService: Successfully reloaded image for author: \(userId)")
        }
    }
}
